---
title: "Axumã§Goã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã€ŒWriting Web Applicationã€ã‚’ã‚„ã£ã¦ã¿ãŸ"
emoji: "ğŸ¦€"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust"]
published: false
---

# ã¯ã˜ã‚ã«
ç§ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ åˆå¿ƒè€…ã§ã™ãŒã€ã“ã‚Œã‹ã‚‰ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã¨ã—ã¦ã®ã‚¹ã‚­ãƒ«ã‚’ã“ã‚Œã‹ã‚‰é«˜ã‚ã¦ã„ããŸã„ã¨ã„ã†æ°—æŒã¡ãŒã‚ã‚Šã¾ã™ã€‚
ãªã®ã§ã¨ã‚Šã‚ãˆãšã€ç¤¾ä¼šã§æ¯”è¼ƒçš„éœ€è¦ã®å¤šã„Webãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰é–‹ç™ºã®åŸºç¤ã‚’ç¿’å¾—ã—ãŸã„ã¨æ€ã„ã¾ã—ãŸã€‚
Webãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯æ˜Ÿã®æ•°ã»ã©ã‚ã‚Œã©ã€ãã‚Œã‚‰ã«å…±é€šã—ãŸè¦ç´ ã¯å¤šã„ã¯ãšã§ã€ãã‚Œã‚’ç¿’å¾—ã—ã¦ã—ã¾ãˆã°ã€æ–°ãŸãªãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’å­¦ã¶ã®ã¯å®¹æ˜“ã«ãªã‚‹ã¨æ€ã£ãŸã®ã§ã€ã¾ãšï¼‘ã¤ã®Webãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã«ã¤ã„ã¦ç¿’ç†Ÿã—ã¦ã„ããŸã„ã¨æ€ã„ã¾ã—ãŸã€‚
ä»•äº‹ã¨é•ã„ã€ä½•ã‚’é¸ã‚“ã§ã‚‚ã„ã„ã®ã§ã€è‡ªåˆ†ã®å¥½ããªè¨€èªã®Rstã®Webãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã‚ã‚‹[`Axum`](https://github.com/tokio-rs/axum)ã‚’é¸ã³ã¾ã—ãŸã€‚
ãŸã ã€Axumã¯ç¾åœ¨ã‚‚æ´»ç™ºã«é–‹ç™ºã•ã‚Œã¦ã„ã‚‹æ–°ã—ã„ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã€ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ãªã©ãŒè¦‹å½“ãŸã‚‰ãªã„ã®ã§ã€Goã®[`net/http`](https://pkg.go.dev/net/http)ã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã€Œ[Writing Web Application](https://golang.org/doc/articles/wiki/)ã€ã‚’Axumã§ã‚„ã£ã¦ã¿ã¾ã—ãŸã€‚


# Axumã¨ã¯
`Axum`ã¯éå¸¸ã«ã‚¹ãƒªãƒ ãªãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã™ã€‚`Axum`ã¯GitHubã®READMEã«æ›¸ã‹ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«**Ergonomics**ã¨**Modularity**ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã—ã¦ã„ã¾ã™ã€‚

# Modularity
`Axum`ã¯è‰²ã€…ãªã‚¯ãƒ¬ãƒ¼ãƒˆãŒãƒ¬ã‚´ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚ˆã†ã«çµ„ã¿åˆã‚ã•ã‚Œã¦ã„ã¾ã™ã€‚
ãŸã¨ãˆã°éåŒæœŸãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯[`tokio`](https://github.com/tokio-rs/tokio)ã€ã‚µãƒ¼ãƒãƒ¼ã¯[`hyper`](https://github.com/hyperium/hyper)ãŒä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚
ã¾ãŸRequestã‚’å—ã‘å–ã‚ŠResponseã‚’è¿”ã™ã‚‚ã®ã‚’æŠ½è±¡åŒ–ã—ãŸã‚µãƒ¼ãƒ“ã‚¹ã¨ã„ã†æ¦‚å¿µã‚’åœŸå°ã¨ã—ã¦ã„ã¾ã™ã€‚ã‚µãƒ¼ãƒ“ã‚¹ã¯[`tower`](https://github.com/tower-rs/tower)ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚
`Axum`ã¯ãã®ã‚µãƒ¼ãƒ“ã‚¹ã®å…·ä½“åŒ–ã§ã‚ã‚‹ãƒãƒ³ãƒ‰ãƒ©ã¨ã€ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã«ç‰¹åŒ–ã—ã¦ã„ã¾ã™ã€‚

# Ergonomics
Ergonomicsã¯äººé–“å·¥å­¦ã¨ã„ã†æ„å‘³ã ãã†ã§ã™ã€‚ä½¿ã„ã‚„ã™ã•ã‚’é‡è¦–ã—ã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ã§ã—ã‚‡ã†ã€‚
ä»¥ä¸‹ã®ã‚ˆã†ãªç‰¹å¾´ãŒã‚ã‚‹ã‚ˆã†ã§ã™ã€‚
## ç‰¹å¾´
### ãƒã‚¯ãƒ­ãƒ•ãƒªãƒ¼ãªãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
Webãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ä¸­ã«ã¯ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³(ãƒã‚¯ãƒ­)ã§ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã™ã‚‹Webãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚‚å¤šã„ã§ã™ãŒã€`Axum`ã¯ãã®æ–¹å¼ã¯æ¡ç”¨ã—ã¦ã„ã¾ã›ã‚“ã€‚
ãƒã‚¯ãƒ­ã¯éå¸¸ã«é«˜ã„è¡¨ç¾åŠ›ã‚†ãˆã«ã€ä½•ã‚’ã—ã¦ã„ã‚‹ã®ã‹åˆ†ã‹ã‚Šã¥ã‚‰ã„ã¨ã„ã†å´é¢ãŒã‚ã‚‹ã®ã§ã€ãªã‚‹ã¹ããã®ä½¿ç”¨ã‚’é¿ã‘ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã€‚
ã¨ã¯ã„ãˆã€ãƒã‚¯ãƒ­ã¯ä½¿ã„ã™ããªã‘ã‚Œã°ã€éå¸¸ã«ä¾¿åˆ©ã§åŠ¹æœçš„ãªæ©Ÿèƒ½ãªã®ã§ã€ã“ã‚Œã¯å¥½ã¿ã®å•é¡Œã‚‚å¤§ãã„æ°—ãŒã—ã¾ã™ã€‚

### å®£è¨€çš„ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆã¨ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ãƒ‘ãƒ¼ã‚¹
Goã®`net/http`ã‚„[echo](https://echo.labstack.com/)ã ã¨ãƒãƒ³ãƒ‰ãƒ©ã¯ã€è¦æ±‚ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’å®Ÿè£…ã—ãŸæ§‹é€ ä½“ã«å¯¾ã—ã¦ã€æ“ä½œã‚’æ–½ã—ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºã—ãŸã‚Šãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã—ãŸã‚Šã—ãŸã‚Šã™ã‚‹æ–¹å¼ã‚’æ¡ç”¨ã—ã¦ã„ã¾ã™ãŒã€Axumã§ã¯ãƒãƒ³ãƒ‰ãƒ©ã¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯0å€‹ä»¥ä¸Šã®`FromRequest`ã‚’å®Ÿè£…ã—ãŸå‹(`Extractor`ã¨å‘¼ã°ã‚Œã¾ã™)ã§ã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¯`IntoResponse`ã‚’å®Ÿè£…ã—ãŸå‹ã§ã™ã€‚
è¨€è‘‰ã ã¨åˆ†ã‹ã‚Šã¥ã‚‰ã„ã®ã§å…·ä½“ä¾‹ã§æ¯”è¼ƒã—ã¦ã¿ã¾ã™ã€‚

```go:net/httpã®ãƒãƒ³ãƒ‰ãƒ©ã®å®šç¾©ã®ä¸€ä¾‹
func handler(w http.ResponseWriter, r *http.Request) { ... }
```

```rust:Axumã®ãƒãƒ³ãƒ‰ãƒ©ã®å®šç¾©ã®ä¸€ä¾‹
async fn hander(uri: Uri, method: Method, headers: HeaderMap, body: Bytes) -> (StatusCode, HeaderMap, &'static str) { ... }
```

`net/http`ã§ã¯`http.ResoponseWriter`ã¨`*http.Request`ã¯ã¾ãšå›ºå®šã§ã™ãŒã€`Axum`ã®å ´åˆã€æ¬²ã—ã„ç‰©ã€è¿”ã—ãŸã„ã‚‚ã®ã‚’å¼•æ•°ã€è¿”ã‚Šå€¤ã«æ›¸ã„ã¦ã„ãã¨ã„ã£ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ã§ã™ã€‚
ã‚ˆãä½¿ã‚ã‚Œã‚‹ã‚‚ã®ã¯äºˆã‚`FromRequest`ã‚„`IntoResponse`ãŒå®Ÿè£…ã•ã‚ŒãŸå‹ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚

# Gowiki
ã€ŒWriting Web Applicationã€ã¯Gowikiã¨ã„ã†è¶…ç°¡æ˜“çš„ãªWikiã‚’ä½œã‚‹ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã§ã™ã€‚
ç°¡å˜ã®ãŸã‚ã€Wikiã®ãƒšãƒ¼ã‚¸ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã§ç®¡ç†ã•ã‚Œã¦ã„ã¾ã™ã€‚
ãƒšãƒ¼ã‚¸ã®å‚ç…§ã€ç·¨é›†(æ–°è¦ä½œæˆ)ã€ä¿å­˜æ©Ÿèƒ½ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚
ç§ãŒæ›¸ã„ãŸ`Axum`ã«ã‚ˆã‚‹å®Ÿè£…ã¯[ä»¥ä¸‹](https://github.com/kokihonda/GowikiByRust)ã«ã‚ã‚Šã¾ã™ã€‚

# åŒã˜æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ãŸAxumã¨net/httpã®ã‚³ãƒ¼ãƒ‰ã‚’è¦‹æ¯”ã¹ãŸã¨ãã®æ‰€æ„Ÿ
`net/http`ã¯GoãŒæ¨™æº–ã§æä¾›ã—ã¦ã„ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã“ã‚Œã‚’ç´ ã§ä½¿ã†ã“ã¨ã¯å°‘ãªã„ã§ã—ã‚‡ã†ãŒã€[æ¸‹å·ã•ã‚“ã®è¨˜äº‹](https://future-architect.github.io/articles/20210714a/)ã«ã‚ˆã‚‹ã¨[`gin`](https://github.com/gin-gonic/gin)ã‚‚`echo`ã‚‚`net/http`ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã¨ã„ã†ã“ã¨ãªã®ã§æ¯”è¼ƒå¯¾è±¡ã¨ã—ã¦ã¯è‰¯ã„ã§ã—ã‚‡ã†ã€‚

## ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
ã¾ãšã€å®Ÿè£…ã‚’è¦‹æ¯”ã¹ã¦ã¿ã¾ã™ã€‚
```go:go
func main() {
    http.HandleFunc("/view/", makeHandler(viewHandler))
    http.HandleFunc("/edit/", makeHandler(editHandler))
    http.HandleFunc("/save/", makeHandler(saveHandler))

    log.Fatal(http.ListenAndServe(":8080", nil))
}
```
https://golang.org/doc/articles/wiki/ ã‹ã‚‰å¼•ç”¨

```rust:rust
#[tokio::main]
async fn main() {
    let app = Router::new()
        .route("/view/:title", get(view))
        .route("/edit/:title", get(edit))
        .route("/save/:title", post(save))
        .layer(extractor_middleware::<ValidTitle>());

    axum::Server::bind(&"127.0.0.1:8080".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}
```

`net/http`ã§ã¾ãšæ°—ã«ãªã£ãŸã®ãŒãƒ‘ãƒƒãƒˆè¦‹ãƒãƒ³ãƒ‰ãƒ©ãŒãƒ«ãƒ¼ã‚¿ã«ç´ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«è¦‹ãˆãªã„ã“ã¨ã§ã™ã€‚
ã“ã®[è¨˜äº‹](https://zenn.dev/hsaki/books/golang-httpserver-internal)ãŒéå¸¸ã«å‚è€ƒã«ãªã‚Šã¾ã—ãŸãŒã€`DefaultServeMux`ã¨ã„ã†ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãŒå­˜åœ¨ã—ã¦ã„ã¦`handlerFunc`ãŒå‘¼ã°ã‚Œã‚‹ã¨`DefaultServeMux`ã«ç´ä»˜ã‘ã‚Œã‚‹ãã†ã§ã™ã€‚
ãã—ã¦ã€`http.ListenAndServe`ã®ç¬¬2å¼•æ•°ã«`nil`ãŒæ¸¡ã•ã‚Œã‚‹ã¨ã‚µãƒ¼ãƒãƒ¼ã«`DefaultServeMux`ãŒæ¸¡ã•ã‚Œã‚‹ã¨ã„ã†ä½œã‚Šã«ãªã£ã¦ã„ã¾ã™ã€‚
çŸ¥ã£ã¦ã—ã¾ãˆã°ãªã‚“ã¦ã“ã¨ã¯ãªã„ã§ã™ãŒã€ç§ã¯æœ€åˆã«ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ãŸæ™‚ã«å°‘ã—æˆ¸æƒ‘ã„ã¾ã—ãŸã€‚

`Axum`ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ãªä½œã‚Šã«è¦‹ãˆã¾ã™ã€‚`Axum`ã¯`hyper`ã®`Server`ã‚’å†ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ã„ã¦`axum::Server::bind(&"127.0.0.1:3000".parse().unwrap()).serve(app.into_make_service()).~~`ã¨ã„ã†ã®ã¯å®Ÿéš›ã¯`hyper`ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚
`hyper`ã®`serve`é–¢æ•°ã¯ã‚µãƒ¼ãƒ“ã‚¹ã‚’å¼•æ•°ã«è¦æ±‚ã™ã‚‹ã®ã§app(ãƒ«ãƒ¼ã‚¿ãƒ¼)ã®`into_make_service()`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã‚µãƒ¼ãƒ“ã‚¹ã«å¤‰æ›ã—ã¦ã„ã¾ã™ã€‚

## ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
ã“ã¡ã‚‰ã‚‚å®Ÿè£…ã‚’ç¤ºã—ã¾ã™ã€‚

```go:go
var validPath = regexp.MustCompile("^/(edit|save|view)/([a-zA-Z0-9]+)$")

func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        m := validPath.FindStringSubmatch(r.URL.Path)
        if m == nil {
            http.NotFound(w, r)
            return
        }
        fn(w, r, m[2])
    }
}
```
https://golang.org/doc/articles/wiki/ ã‹ã‚‰å¼•ç”¨

```rust:rust
pub struct ValidTitle;

#[async_trait]
impl<B> FromRequest<B> for ValidTitle
where
    B: Send,
{
    type Rejection = (StatusCode, HeaderMap, String);

    async fn from_request(req: &mut RequestParts<B>) -> Result<Self, Self::Rejection> {
        let re = Regex::new(r"^/[a-zA-Z0-9]+$").unwrap();

        let path = req.uri().path();
        let title = path
            .trim_start_matches('/')
            .trim_start_matches(|c| c != '/');

        if !re.is_match(title) {
            return Err((
                StatusCode::NOT_FOUND,
                HeaderMap::new(),
                "invalid Page Title".to_string(),
            ));
        }

        Ok(Self)
    }
}
/**
    let app = Router::new()
        .route("/view/:title", get(view))
        .route("/edit/:title", get(edit))
        .route("/save/:title", post(save))
        .layer(extractor_middleware::<ValidTitle>()); // 1. ã“ã“ã§ä½¿ç”¨ã€‚
*/
```

ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã§ã¯URLã®pathã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã™ã‚‹ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚’å®Ÿè£…ã™ã‚‹ç« ãŒã‚ã‚Šã¾ã—ãŸã€‚
`net/http`ã‚‚`Axum`ã‚‚ãƒãƒ³ãƒ‰ãƒ©ã«æ©Ÿèƒ½ã‚’ä»˜åŠ ã™ã‚‹ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã¨ã„ã†ä»•çµ„ã¿ã‚’æŒã£ã¦ã„ã¾ã™ã€‚`net/http`ã¯ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã¯`handlerFunc`ã‚’è¿”ã™é–¢æ•°ã‚’å¼•æ•°ã«ã¨ã‚Šã€`handerFunc`ã‚’è¿”ã™ã¨ã„ã†éå¸¸ã«ä½œã‚Šã«ãªã£ã¦ã„ã¾ã™ã€‚
ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã¦æ°—ã«ãªã£ãŸã®ã¯å¼•æ•°ã®é–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ã«æˆ»ã‚Šå€¤ãŒæ›¸ã‹ã‚Œã¦ã„ãªã„ã“ã¨ã§ã™ã€‚ã“ã‚Œã¯æ¨è«–ã•ã‚Œã‚‹ã¨ã„ã†ã“ã¨ãªã®ã§ã—ã‚‡ã†ã‹ã€‚ã€‚

`Axum`ã¯`tower`ã®ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã®ä»•çµ„ã¿ã‚’ã‚·ãƒ¼ãƒ ãƒ¬ã‚¹ã«ä½¿ãˆã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚`tower`ã«ãŠã‘ã‚‹ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã¨ã¯ã‚µãƒ¼ãƒ“ã‚¹ã‚’å—ã‘å–ã£ã¦ã‚µãƒ¼ãƒ“ã‚¹ã‚’è¿”ã™ã‚‚ã®ã§ã™ã€‚
å€‹ã€…ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã«æ©Ÿèƒ½ã‚’ä»˜åŠ ã—ãŸã„å ´åˆã€ãƒãƒ³ãƒ‰ãƒ©ã®`layer`é–¢æ•°ã‚’å‘¼å‡ºã—ã€ãƒ«ãƒ¼ã‚¿ãƒ¼ã«ç´ä»˜ã„ã¦ã„ã‚‹ãƒãƒ³ãƒ‰ãƒ©ãƒ¼å…¨ä½“ã«æ©Ÿèƒ½ã‚’ä»˜åŠ ã—ãŸã„å ´åˆã¯ãƒ«ãƒ¼ã‚¿ãƒ¼ã®`layer`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚
ã‚‚ã¨ã‚‚ã¨å­˜åœ¨ã™ã‚‹ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚’ä½¿ã†ã®ã¯ç°¡å˜ãªã®ã§ã™ãŒã€ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚’è‡ªä½œã™ã‚‹ã®ã¯æ…£ã‚ŒãŒå¿…è¦ã§ã™ã€‚ã¨ã„ã†ã®ã‚‚ã‚µãƒ¼ãƒ“ã‚¹ã¨ã„ã†ã®ã¯`Future`ã‚’è¿”ã™é–¢æ•°ã§ã™(`Future`ã¯Rustã§éåŒæœŸã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã®ã‚­ãƒ¼ã¨ãªã‚‹æ¦‚å¿µã®ï¼‘ã¤ã§ã™)ã€‚
ãªã®ã§ã‚µãƒ¼ãƒ“ã‚¹ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹ã«ã¯Rustã®éåŒæœŸã®ä»•çµ„ã¿ã«é–¢ã™ã‚‹ã‚ã‚‹ç¨‹åº¦ã®çŸ¥è­˜ãŒå¿…è¦ã¨ãªã‚Šã¾ã™ã€‚ä¾‹ã¨ã—ã¦TimeoutãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã®å®Ÿè£…ã‚’ç¤ºã—ã¾ã™ã€‚

```rust:timeoutã®ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã®å®Ÿè£…
use pin_project::pin_project;
use std::time::Duration;
use std::{
    fmt,
    future::Future,
    pin::Pin,
    task::{Context, Poll},
};
use tokio::time::Sleep;
use tower::Service;

#[derive(Debug, Clone)]
struct Timeout<S> {
    inner: S,
    timeout: Duration,
}

impl<S> Timeout<S> {
    fn new(inner: S, timeout: Duration) -> Self {
        Timeout { inner, timeout }
    }
}

impl<S, Request> Service<Request> for Timeout<S>
where
    S: Service<Request>,
    S::Error: Into<BoxError>,
{
    type Response = S::Response;
    type Error = BoxError;
    type Future = ResponseFuture<S::Future>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx).map_err(Into::into)
    }

    fn call(&mut self, request: Request) -> Self::Future {
        let response_future = self.inner.call(request);
        let sleep = tokio::time::sleep(self.timeout);

        ResponseFuture {
            response_future,
            sleep,
        }
    }
}

#[pin_project]
struct ResponseFuture<F> {
    #[pin]
    response_future: F,
    #[pin]
    sleep: Sleep,
}

impl<F, Response, Error> Future for ResponseFuture<F>
where
    F: Future<Output = Result<Response, Error>>,
    Error: Into<BoxError>,
{
    type Output = Result<Response, BoxError>;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        let this = self.project();

        match this.response_future.poll(cx) {
            Poll::Ready(result) => {
                let result = result.map_err(Into::into);
                return Poll::Ready(result);
            }
            Poll::Pending => {}
        }

        match this.sleep.poll(cx) {
            Poll::Ready(()) => {
                let error = Box::new(TimeoutError(()));
                return Poll::Ready(Err(error));
            }
            Poll::Pending => {}
        }

        Poll::Pending
    }
}

#[derive(Debug, Default)]
struct TimeoutError(());

impl fmt::Display for TimeoutError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.pad("request timed out")
    }
}

impl std::error::Error for TimeoutError {}

type BoxError = Box<dyn std::error::Error + Send + Sync>;
```
https://github.com/tower-rs/tower/blob/master/guides/building-a-middleware-from-scratch.md ã‹ã‚‰å¼•ç”¨

ã¨ã¯ã„ãˆã€ç‹¬è‡ªã®ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚’å®Ÿè£…ã—ãŸã‘ã‚Œã°ã“ã®ã‚ˆã†ãªå®Ÿè£…ã‚’ã—ãªã‘ã‚Œã°è¡Œã‘ãªã„ã‚ã‘ã§ã¯ãªãã€Axumã«ã¯`Extractor`ã‚’ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚’å¤‰æ›ã™ã‚‹[é–¢æ•°](https://docs.rs/axum/0.3.2/axum/extract/extractor_middleware/index.html)ãŒå­˜åœ¨ã—ã¾ã™ã€‚ç§ã®å®Ÿè£…ã§ã¯ã“ã‚Œã‚’ç”¨ã„ã¾ã—ãŸã€‚

## æ­£å¸¸ç³»ä»¥å¤–ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®è¿”ã—æ–¹
ã‚µãƒ¼ãƒãƒ¼ã¯å¸¸ã«æ­£å¸¸ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™ã‚ã‘ã§ã¯ãªãã€INTERNAL_SERVER_ERRORã€BAD_REQUESTã€UNAUTHORIZEDãªã©ã®ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚
ã“ã‚Œã®å®Ÿç¾æ–¹æ³•ã§ã™ãŒnet/httpã¯ã“ã‚Œã¾ãŸã‚·ãƒ³ãƒ—ãƒ«ã§`http.NotFound`ã®ã‚ˆã†ã«å‘¼ã¶ã ã‘ã§ã—ãŸã€‚
Axumã®å ´åˆã¯`Result`ã‚’ä½¿ã„ã¾ã™ã€‚Rustã¯åˆ—æŒ™å‹ã¨ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã¨ã„ã†æ©Ÿæ§‹ãŒè¨€èªã®çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã™ã€‚
`Result`ã¯åˆ—æŒ™å‹ã§ä»¥ä¸‹ã®ã‚ˆã†ãªå®šç¾©ã«ãªã£ã¦ã„ã¦`OK<T>`ã‹`Err<E>`ã‚’è¡¨ç¾ã—ã¾ã™ã€‚

```rust:Resultã®å®šç¾©
pub enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

ãŸã Axumã§å®Ÿè£…ã—ãŸã¨ãã«ã€å°‘ã—å›°ã£ãŸã“ã¨ãŒã‚ã‚Šã¾ã—ãŸã€‚Wikiã®ãƒšãƒ¼ã‚¸ã‚’è¿”ã™viewé–¢æ•°ã§ã¯ã€ãƒšãƒ¼ã‚¸ãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã€ãƒšãƒ¼ã‚¸ãŒè¦‹ã¤ã‹ã‚Œã°ãã®ãƒšãƒ¼ã‚¸ã‚’è¿”ã—ã¾ã™ã€‚
Goã ã¨ä»¥ä¸‹ã®ã‚ˆã†ãªå®Ÿè£…ã«ãªã‚Šã¾ã™ã€‚

```go
func viewHandler(w http.ResponseWriter, r *http.Request, title string) {
    p, err := loadPage(title)
    if err != nil {
        http.Redirect(w, r, "/edit/"+title, http.StatusFound)
        return
    }
    renderTemplate(w, "view", p)
}
```
https://golang.org/doc/articles/wiki/ ã‹ã‚‰å¼•ç”¨


ç§ã¯Rustã§ã¯æœ€åˆä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ãã¾ã—ãŸã€‚

```rust
async fn view(Path(title): Path<String>) -> Result<impl IntoResponse, impl IntoResponse> {
    let page = match load_page(&title) {
        Ok(page) => page,
        Err(_) => return Err(Redirect::found(format!("/edit/{}", title))), // 1. Redirectã‚’è¿”ã™ã€‚
    };

    let mut context = Context::new();
    context.insert("title", &page.title);
    context.insert("body", &String::from_utf8(page.body).unwrap());

    match TEMPLATES.render("view.html", &context) {
        Ok(html) => Ok(Html(html)),
        Err(err) => Err(handle_error(err)), // 2.(StatusCode, HeaderMap, String)ã‚’è¿”ã™ã€‚
    }
}
fn handle_error(err: impl std::error::Error) -> (StatusCode, HeaderMap, String) {
    (
        StatusCode::INTERNAL_SERVER_ERROR,
        HeaderMap::new(),
        format!("Something went wrong: {}", err),
    )
}

```
ã—ã‹ã—ã“ã‚Œã¯ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚ãªãœãªã‚‰1ã¨2ã§è¿”ã™å‹ãŒé•ã†ã‹ã‚‰ã§ã™ã€‚å¾“ã£ã¦ç§ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚¨ãƒ©ãƒ¼ã§è¿”ã™å‹ã‚’ä¸€è‡´ã•ã›ã¾ã—ãŸã€‚

```rust
async fn view(Path(title): Path<String>) -> Result<impl IntoResponse, impl IntoResponse> {
    let page = match load_page(&title) {
        Ok(page) => page,
        Err(_) => return Err(handle_redirect(&title)), // 1.(StatusCode, HeaderMap, String)ã‚’è¿”ã™ã€‚
    };

    let mut context = Context::new();
    context.insert("title", &page.title);
    context.insert("body", &String::from_utf8(page.body).unwrap());

    match TEMPLATES.render("view.html", &context) {
        Ok(html) => Ok(Html(html)),
        Err(err) => Err(handle_error(err)), // 2.(StatusCode, HeaderMap, String)ã‚’è¿”ã™ã€‚
    }
}

fn handle_error(err: impl std::error::Error) -> (StatusCode, HeaderMap, String) {
    (
        StatusCode::INTERNAL_SERVER_ERROR,
        HeaderMap::new(),
        format!("Something went wrong: {}", err),
    )
}

fn handle_redirect(title: &str) -> (StatusCode, HeaderMap, String) {
    let mut headers = HeaderMap::new();
    headers.insert(
        axum::http::header::LOCATION,
        HeaderValue::from_str(&format!("/edit/{}", title)).unwrap(),
    );

    (StatusCode::TEMPORARY_REDIRECT, headers, "".to_string())
}
```

ã—ã‹ã—Redirectã‚’è¿”ã™é–¢æ•°ãŒã‚ã‚‹ã®ã«ã€æ‰‹å‹•ã§ãƒ˜ãƒƒãƒ€ãƒ¼ã«`Location`ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã¨ã„ã†ã®ã‚‚å¤‰ãªæ„Ÿã˜ã§ã™ã€‚
ãŠãã‚‰ãã„ã„ã‚„ã‚Šæ–¹ã¯ã‚ã‚‹ã‚“ã§ã—ã‚‡ã†ãŒã€ç§ã«ã¯åˆ†ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚

## çµ‚ã‚ã‚Šã«
æœ¬è¨˜äº‹ã§ã¯`Axum`ã§Goã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã€ŒWriting Web Applicationã€ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã—ãŸã€‚
æƒ…å ±ãŒå°‘ãªã„ãŸã‚ã€ã€Œã“ã†ã„ã†ã¨ãã«ã©ã†æ›¸ãã®ï¼Ÿã€ã¨ã„ã†ç–‘å•ã‚’è§£æ¶ˆã—ã¥ã‚‰ã„é¢ã¯ã‚ã‚Šã¾ã—ãŸãŒã€ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯è‡ªä½“ã¯ã¨ã¦ã‚‚ä½¿ã„ã‚„ã™ã‹ã£ãŸã§ã™ã€‚
ã‚‚ã£ã¨RustãŒä½¿ã‚ã‚Œã‚‹ä¸–ã®ä¸­ã«ãªã‚‹ã¨è‰¯ã„ãªã‚ã¨æ„Ÿã˜ã¾ã—ãŸã€‚